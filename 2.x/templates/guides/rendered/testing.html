<h2 class="page-title" id="introduction-to-testing">Introduction to Testing</h2><p>In order to support continuous development/integration, taking advantage of automated testing is a must. While the goal of automated testing is to provide full coverage, it also needs to be seamlessly integrated into the developer environment. This document describes the testing setup for EncoreUI.</p>
<h3  id="configuration-files">Configuration Files</h3><p>More details on these files are found in the files themselves</p>
<p><strong>karma.conf.js</strong> - Used by component unit tests</p>
<p><strong>protractor.conf.js</strong> - Used by our midway/E2E tests</p>
<p><strong>protractor.visual.regression.js</strong> - Used by our visual regression tests (Travis CI only)</p>
<h3  id="component-tests-aka-unit-tests">Component Tests (aka unit tests)</h3><p><em>Goal: Tests smallest piece of functionality or method</em></p>
<ul>
<li>Code level tests</li>
<li>Uses <a href="http://karma-runner.github.io">Karma</a> + <a href="http://mochajs.org/">Mocha</a> + <a href="http://chaijs.com/">Chai</a> + <a href="http://sinonjs.org/">Sinon</a></li>
<li>Stored in same location as code (separate file with *.spec.js)</li>
<li>Best for testing services, classes and objects</li>
<li>Does contain &quot;functional&quot; tests (can test browser interactions like &#39;click&#39;)</li>
<li>Sandboxed &amp; Isolated testing</li>
<li>Mocking &amp; Stubbing required</li>
<li>Fast</li>
</ul>
<p>Unit tests automatically execute when running <code>grunt server</code>. It&#39;s best to run your tests in this fashion, as they automatically re-run on file changes.</p>
<p>If you wish to run them separately, use <code>grunt test</code>. To aid in debugging unit tests, you can use <code>grunt test:debug</code>. <a href="" ng-click="vm.scrollTo('debugging-unit-tests')">Details on this are explained below</a>.</p>
<h4  id="testing-individual-components">Testing Individual Components</h4><p>When developing a specific component, you likely don&#39;t want to run the entire test suite on every change. In order to test a single set of functionality, use the &#39;only&#39; function when describing your test. For example:</p>
<pre><code class="lang-js">describe.only(&#39;Login&#39;, function () {
    // ... tests go here ...
});
</code></pre>
<p><strong>Be sure to remove the <code>only</code> once you&#39;re done.</strong></p>
<h4  id="code-coverage">Code Coverage</h4><p>Code coverage stats for our component tests are generated every time the test suite is executed. To view the stats, simply open the index.html file in any of the browser directories in the &#39;coverage&#39; directory. <strong>Note</strong>: the coverage directory only exists when the server is running.</p>
<h4  id="debugging-unit-tests">Debugging Unit Tests</h4><p>When writing or debugging unit tests and code, it can be helpful to enter the Chrome debugger to step through lines of code and inspect variables. The command <code>grunt test:debug</code> configures your environment to do this. To use it:</p>
<ol>
<li>Run <code>grunt test:debug</code>. This will open a new Chrome window and runs all the tests</li>
<li>Open the Inspector in Chrome (<code>Command-Option-i</code> on a Mac), and reload the Chrome page (<code>Command-R</code> / <code>Ctrl-R</code> / etc.). This will re-run all the tests</li>
<li>Insert a <code>debugger</code> statement somewhere in your code or your tests. The tests will automatically re-run when you save your file.  Now when the tests re-run, they will pause in the Inspector at the <code>debugger</code> statement (automatically switching to the &quot;Sources&quot; tab), allowing you to step through and inspect!</li>
</ol>
<p>Especially when debugging tests, it can be useful to use the <a href="" ng-click="vm.scrollTo('testing-individual-components')">individual component testing</a> technique above, so you don&#39;t have to wait for all 600+ tests to run every time you save a file or reload the Chrome page.</p>
<h3  id="midway-tests">Midway Tests</h3><p><em>Goal: Validate our component in a full browser</em></p>
<ul>
<li>Uses an example instance of the component</li>
<li>Uses <a href="https://code.google.com/p/selenium/wiki/WebDriverJs">Selenium</a>, <a href="https://github.com/angular/protractor/">Protractor</a>, <a href="https://github.com/stuplum/astrolabe">Astrolabe</a></li>
<li>Somewhat slow</li>
<li>Story Based</li>
</ul>
<h4  id="the-testing-environment">The Testing Environment</h4><p>The test code for this project isn&#39;t just to validate the correctness of the encore-ui component library. Like the encore-ui project itself, it is designed to be shared between various projects.</p>
<p>Because of this, the test code (called &quot;rx-page-objects&quot;) is organized to be exported as a stand alone node package. The directory where this project is hosted can be found in <code>./utils/rx-page-objects</code>. This directory contains its own <code>package.json</code> file, <code>.gitignore</code> file, and other project-specific files.</p>
<p>As a contributor, when you run <code>npm install</code> in the root of this project, it will automatically install the rx-page-object dependencies for you too. If you find that you&#39;re having trouble running end to end tests, try deleteing the <code>utils/rx-page-objects/node_modules</code> directory and reinstalling dependencies there.</p>
<h4  id="running-tests">Running Tests</h4><p>In order to run the midway test suite, you will need a Selenium server running. To install and run Selenium, execute the webdriver-manager. To do this, open a new terminal window and run the following from the <code>encore-ui</code> directory:</p>
<pre><code>cd utils/rx-page-objects/
./node_modules/.bin/webdriver-manager update # First time only
./node_modules/.bin/webdriver-manager start
</code></pre><p>This will launch the selenium server. It can sometimes take 25-30 seconds to fully launch, and you&#39;ll know it&#39;s ready when you see this at the bottom of the terminal:</p>
<pre><code>INFO - Started SocketListener on 0.0.0.0:4444
INFO - Started org.openqa.jetty.jetty.Server@401363ff
</code></pre><p>Make sure you keep this terminal window running!</p>
<p>To run all tests, enter <code>./node_modules/.bin/protractor</code> from the <code>encore-ui/utils/rx-page-objects</code> directory, in a different terminal. You need to ensure that you already have a development server running. If you haven&#39;t already, run <code>grunt server</code> in a separate terminal. You will need to keep this running in the background through the entirety of the midway tests.</p>
<p>In other words, to run the tests, you need a total of <em>three</em> terminal windows.</p>
<ul>
<li>One terminal running the Selenium server</li>
<li>One terminal running <code>grunt server</code></li>
<li>One terminal running <code>./utils/rx-page-objects/node_modules/.bin/protractor</code></li>
</ul>
<h5  id="testing-individual-components">Testing Individual Components</h5><p>When developing a specific component, it&#39;s much quicker to run tests only for that component (rather than run through the entire suite every time). To do this, pass in path to the file as a &#39;specs&#39; option in your protractor command. For example:</p>
<pre><code>cd utils/rx-page-objects/
./node_modules/.bin/protractor --specs test/rxComponent.midway.js
</code></pre><h4  id="convenience-page-objects">Convenience Page Objects</h4><p>In order to help developers more easily test their own apps/projects, each EncoreUI component should provide a page object file for itself. This file will provide convenience methods for the tester to use when writing midway tests for their app.</p>
<p>The filename for these page objects follows the <code>componentName.page.js</code> convention, and will automatically be generated if you create a new EncoreUI component with the <a href="#/guides/ui-setup#component-scaffolding">Component Scaffolding</a></p>
<p>On a build of EncoreUI, all page object files are concatenated and tarballed into the <code>dist</code> directory. They are then published either manually or via Travis. To use these page objects, developers should include the following dependency in their app&#39;s <code>package.json</code> file:</p>
<pre><code>&quot;rx-page-objects&quot;: &quot;^2.0.0&quot;
</code></pre><p>Alternatively, they can install the file using this command:</p>
<pre><code>npm install --save-dev rx-page-objects@2
</code></pre><p>Once installed, the page objects can be pulled in to any midway test via:</p>
<pre><code class="lang-js">var someEncoreUIComponent = require(&#39;rx-page-objects&#39;).someEncoreUIComponent;
// ...
expect(someEncoreUIComponent.initialize($(&#39;.my-component&#39;)).isDisplayed()).to.eventually.be.true;
</code></pre>
<p>Alternatively, you could place this helper library in the global scope of all tests. This is the recommended way. In your project&#39;s protractor config file, add this to your <code>onPrepare</code> section.</p>
<pre><code class="lang-js">onPrepare: function () {
    encore = require(&#39;rx-page-objects&#39;);
}
</code></pre>
<p>Keep in mind you&#39;ll need to register a global variable declaration in your linting file (<code>.jshintrc</code>, etc.).</p>
<h4  id="convenience-page-object-exercises">Convenience Page Object Exercises</h4><p>Convenience page objects exist to abstract away many of the tedious commands needed to direct a component during tests that prove high-level business functionality in your tests. However, many tests should still be run to ensure that your app&#39;s encore-ui components were &quot;wired up&quot; correctly. They should respond to activities that many users will exercise during normal operation. Instead of duplicating these tests in every instance of a component in your app, you can include that page object&#39;s exercise using this pattern:</p>
<pre><code class="lang-js">// assuming you&#39;ve included `encore = require(&#39;rx-page-objects&#39;)` in your protractor conf&#39;s onPrepare step
describe(&#39;Home Page&#39;, function () {

    before(function () {
        loginPage.login();
        homePage.search(&#39;My Term&#39;);
    });

    it(&#39;should have a pagination component present&#39;, function () {
        expect(homePage.resultsTable.pagination.rootElement.isPresent()).to.eventually.be.true;
    });

    // you can skip many tests by simply doing this instead
    describe(&#39;search result pagination&#39;, encore.exercise.rxPaginate({
        cssSelector: &#39;.my-table .rx-paginate&#39;
    }));

});
</code></pre>
<p>The above snippet would run a couple dozen basic tests, assuming there are no edge cases in your app&#39;s implementation of the pagination component. Examples of such edge cases might be having less than three pages of total pagination space, or defaulting to a very large or small number of results by default.</p>
<h4  id="handling-edge-cases-in-exercises">Handling Edge Cases in Exercises</h4><p>If you do have edge cases, many of the exercises support passing in an <code>options</code> argument, which should be documented in the <a href="https://www.npmjs.com/package/rx-page-objects">npm home page for rx-page-objects</a>. This allows you to specify aspects of a particular component&#39;s implementation to the exercise function, allowing it to skip certain tests that are not valid.</p>
<h3  id="ui-regression-tests">UI Regression Tests</h3><p><em>Goal: Prevent visual regressions by making it easier to compare changes</em></p>
<p><a href="https://github.com/rackerlabs/encore-ui-screenshots">encore-ui-screenshots</a> is used in EncoreUI for UI regression testing. Currently, it will compare the visual elements of the master branch with your branch during Travis CI pull request runs.</p>
<h4  id="running-tests">Running Tests</h4><p>Simply put, you shouldn&#39;t run these tests! They run invisibly on the Travis CI server only. This keeps contributors from checking out megabytes of image comparison files that aren&#39;t necessary for development.</p>
<p>But if you do want to run the tests, feel free to run them by themselves to populate a fresh copy of screenshots locally:</p>
<pre><code>cd utils/rx-page-objects/
npm install snappit-mocha-protractor
./node_modules/.bin/protractor protractor.visual.regression.conf.js
</code></pre><p>This is useful only for experimenting with what your screenshots look like <em>on your current operating system</em>, at <em>your current resolution</em>, and your <em>specific version of your browser</em>! This is why it is recommended that you refrain from running these tests locally. They are designed to run on one machine and one machine only, to ensure that any visual regressions are triggered by visual changes, and not differences in hardware or software.</p>
<p>Note, that there are detailed install instructions for <code>snappit-mocha-protractor</code> <a href="https://github.com/rackerlabs/snappit-mocha-protractor/wiki#introduction">ocated on its wiki page</a></p>
<h4  id="triggering-visual-regression-runs-on-travis">Triggering Visual Regression Runs on Travis</h4><p>In order to get a visual regression to run against your PR, <strong>you must push your pull request directly to the remote repository located at <code>rackerlabs/encore-ui</code>, and not a fork</strong>. codeship.io will not run its tests against pull requests originating from forks.</p>
<p>Visual regressions include posting an reference link from a pull request in the encore-ui-screenshots repository to the current pull request. It looks like this:</p>
<p><img src="https://cloud.githubusercontent.com/assets/1214609/7617973/73d8f30c-f974-11e4-9824-141138a13f30.png" alt="A pull request with a screenshot mention."></p>
<p>Click the reference link to the encore-ui-screenshots pull request, and check out the &quot;Files&quot; tab to see any visual changes introduced in the pull request.</p>
<h4  id="creating-a-new-baseline-for-visual-regression">Creating a New Baseline for Visual Regression</h4><p>Once a pull request has been visually signed off on, it should become the new baseline which all new pull requests are compared against. Do this by visiting the link to the encore-ui-screenshots pull request and merging it. From then on, Travis CI pull request builds will pull <em>those</em> screenshots and compare against them from now on.</p>
<h4  id="creating-new-visual-regression-tests">Creating New Visual Regression Tests</h4><p>The visual regression tests are located in <a href="https://github.com/rackerlabs/encore-ui/blob/master/utils/visual-regression">the <code>utils/visual-regression</code> directory</a>. Inside that, there is a directory for <code>layouts</code> (typically reserved for pages that demonstrate how a typical EncoreUI layout should look), and a directory for components.</p>
<p>When adding a new visual regression test, remember to keep the names of the tests short. The screenshot comparison library creates the image names based on the test names, so there&#39;s no need to be very specific.</p>
<p>Each <code>it()</code> block describes an individual visual regression test. <code>screenshot.snap()</code> is used to grab an area of the screen, and compare it to the current visual baseline, checking for changes. Any detected change will cause a visual diff to be created, with a link to it automatically added to the PR.</p>
<p>Here&#39;s an example of a basic visual regression test for a single component.</p>
<pre><code class="lang-js">// utils/visual-regression/components/rxComponent.midway.js

var myPage = {
    get myComponent() {
        return encore.rxComponent.initialize($(&#39;.my-component&#39;));
    }
};

describe(&#39;demo component&#39;, function () {

    before(function () {
        demoPage.go(&#39;#/components/rxComponent&#39;);
    });

    it(&#39;default&#39;, function () {
        // default screenshot of just the component -- no interaction yet
        screenshot.snap(this, $(&#39;.tab-content rx-component&#39;));
    });

    it(&#39;interactive&#39;, function () {
        myPage.myComponent.interactWith(); // trigger some click that expands something
        // this will capture the component in its current &quot;interacted&quot; state
        screenshot.snap(this, myPage.myComponent.rootElement);
    });

});
</code></pre>
